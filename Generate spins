################################################################################
# Section 1: Imports and Global Settings
################################################################################
import os
import warnings
import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib
import matplotlib.pyplot as plt

# Custom Libraries (assuming they exist, with a fallback for standalone execution)
try:
    from CustomLib.EVAE_Modules import *
    from CustomLib.Other_Modules import *
    print("Successfully imported CustomLib.")
except ImportError:
    print("Warning: CustomLib not found. Please ensure it is in the Python path.")
    # Define placeholder functions if CustomLib is not available
    def get_rotmat(edges): return np.zeros((len(edges), 3, 3))
    def get_nnidx(edges): return -np.ones((len(edges), 6))
    def get_IC(length, rotmat, batch_size=1): return np.random.choice([-1, 1], size=(batch_size, length, 3))
    def get_dipbasis(centers, dr, nnidx): return np.zeros((2, 3, len(centers), len(centers)))
    def get_dipheff(tfX, dip, dipBasis): return tf.zeros_like(tfX)
    def get_MultiFlip_MPMC_engine(tfX, T, heff): return tf.random.normal(tf.shape(tfX))
    class MyClock:
        def init(self): self.start_time = time.time()
        def tictoc(self): 
            elapsed = time.time() - self.start_time
            self.start_time = time.time()
            return elapsed

# --- TensorFlow and Matplotlib Configuration ---
# This script uses TensorFlow 1.x features with compat.v1
tf.compat.v1.disable_eager_execution()
warnings.filterwarnings('ignore', category=FutureWarning)
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

try:
    matplotlib.use('TkAgg')
except ImportError:
    try: matplotlib.use('Qt5Agg')
    except ImportError: matplotlib.use('Agg') # Fallback for non-GUI environments

os.environ["CUDA_VISIBLE_DEVICES"] = "1"

# --- Global variable for storing hexagon centers after removal ---
hex_centers_post_removal = None

################################################################################
# Section 2: Hexagonal Lattice Generation and Manipulation
################################################################################
def generate_flat_top_hexagon_vertices(center, a=1.0):
    """Calculates the 6 vertices of a flat-top hexagon given its center."""
    x0, y0 = center
    angles_rad = np.deg2rad([60 * i for i in range(6)])
    x = x0 + a * np.cos(angles_rad)
    y = y0 + a * np.sin(angles_rad)
    return list(zip(x, y))

def offset_to_cartesian(col, row, a=1.0):
    """Converts offset grid coordinates (col, row) to Cartesian coordinates (x, y)."""
    x = a * 3/2 * col
    y = a * np.sqrt(3) * (row + 0.5 * (col % 2))
    return x, y

def generate_hexagon_grid(cols=10, rows=10, a=1.0):
    """Generates a grid of hexagon centers with their grid indices."""
    hex_centers_list = []
    for c in range(cols):
        for r in range(rows):
            center_x, center_y = offset_to_cartesian(c, r, a)
            hex_centers_list.append(((center_x, center_y), c, r))
    print(f"[Grid Generation] Generated {len(hex_centers_list)} hex centers ({cols}x{rows}).")
    return hex_centers_list

def remove_hex_by_colrow(hex_centers_list, col_target, row_target):
    """Removes a specific hexagon from the list by its column and row index."""
    initial_count = len(hex_centers_list)
    filtered_list = [item for item in hex_centers_list if not (item[1] == col_target and item[2] == row_target)]
    if len(filtered_list) < initial_count:
        print(f"[Hex Removal] Removed hex at (col={col_target}, row={row_target}). New count: {len(filtered_list)}")
    else:
        print(f"[Hex Removal] Hex at (col={col_target}, row={row_target}) not found for removal.")
    return filtered_list

################################################################################
# Section 3: Lattice Structure Processing and CSV I/O
################################################################################
def get_edge_key(v1, v2, precision=6):
    """Creates a unique, order-independent key for an edge from its vertices."""
    v1_rounded = (round(v1[0], precision), round(v1[1], precision))
    v2_rounded = (round(v2[0], precision), round(v2[1], precision))
    return tuple(sorted([v1_rounded, v2_rounded]))

def save_unique_lattice_to_csv(hex_centers_list, a=1.0, filename="Original_Lattice.csv"):
    """Generates unique edges from hexagons and saves them to a CSV file."""
    edges_dict = {}
    for item in hex_centers_list: # Use the list of hexagons after removal
        center_coords = item[0]
        vertices = generate_flat_top_hexagon_vertices(center_coords, a)
        for i in range(6):
            v1, v2 = vertices[i], vertices[(i + 1) % 6]
            key = get_edge_key(v1, v2)
            if key not in edges_dict:
                mid_x, mid_y = (v1[0] + v2[0]) / 2.0, (v1[1] + v2[1]) / 2.0
                # X1, Y1, X2, Y2, XC, YC, SkFpIndex (0.0 for original lattice)
                edges_dict[key] = (v1[0], v1[1], v2[0], v2[1], mid_x, mid_y, 0.0)

    rows_list = list(edges_dict.values())
    num_edges = len(rows_list)
    
    df = pd.DataFrame(rows_list, columns=["X1", "Y1", "X2", "Y2", "XC", "YC", "SkFpIndex"])
    df.to_csv(filename, index=False, float_format='%.4f')
    print(f"[CSV Save] Saved '{filename}' with {num_edges} unique edges.")
    return filename

def load_structure_from_csv(filename):
    """Loads lattice structure (edges, centers, pin indices) from a CSV file."""
    try:
        data = pd.read_csv(filename)
        edges = data[["X1", "Y1", "X2", "Y2"]].values.astype(np.float32)
        centers = data[["XC", "YC"]].values.astype(np.float32)
        skfp = data["SkFpIndex"].values.astype(np.float32)
        print(f"[CSV Load] Loaded {len(edges)} edges/spins from '{filename}'.")
        unique, counts = np.unique(skfp, return_counts=True)
        print(f"[CSV Load] SkFpIndex counts: {dict(zip(unique, counts))}")
        return edges, centers, skfp
    except FileNotFoundError:
        print(f"[CSV Load] Error: File '{filename}' not found.")
        return None, None, None
    except KeyError as e:
        print(f"[CSV Load] Error: Missing column {e} in '{filename}'.")
        return None, None, None

################################################################################
# Section 4: Pin Addition Logic
################################################################################
def _append_pins_aligned(input_csv, output_csv, a, pin_threshold, pin_edge_length, pin_interval, side, skfp_index):
    """Internal helper function to add aligned pins to a specified side of the lattice."""
    try:
        data = pd.read_csv(input_csv)
    except FileNotFoundError:
        print(f"[_append_pins] Error: Input CSV '{input_csv}' not found.")
        return None

    global hex_centers_post_removal
    if hex_centers_post_removal is None or not hex_centers_post_removal:
        raise ValueError(f"[_append_pins] Global 'hex_centers_post_removal' must be set for side '{side}'.")
        
    centers_arr = np.array([item[0] for item in hex_centers_post_removal])
    if centers_arr.size == 0:
        raise ValueError(f"[_append_pins] No hexagon centers available for side '{side}'.")

    if pin_edge_length is None: pin_edge_length = a

    coord_idx, boundary_val, compare_func = -1, 0.0, None
    side_map = {
        'top': (1, centers_arr[:, 1].max(), lambda coord, val, th: coord >= val - th),
        'bottom': (1, centers_arr[:, 1].min(), lambda coord, val, th: coord <= val + th),
        'left': (0, centers_arr[:, 0].min(), lambda coord, val, th: coord <= val + th),
        'right': (0, centers_arr[:, 0].max(), lambda coord, val, th: coord >= val - th)
    }
    if side not in side_map:
        raise ValueError(f"Invalid side specified: {side}")

    coord_idx, boundary_val, compare_func = side_map[side]
    print(f"[Append Pins] Finding '{side}' boundary near {'xy'[coord_idx]}={boundary_val:.4f}...")
    
    boundary_hexagons = [item for item in hex_centers_post_removal if compare_func(item[0][coord_idx], boundary_val, pin_threshold)]
    
    new_pins, pinned_count = [], 0
    for i, item in enumerate(boundary_hexagons):
        if i % pin_interval == 0:
            center_coords, _, _ = item
            vertices = generate_flat_top_hexagon_vertices(center_coords, a)
            
            # Find the outermost vertices on the specified side
            if side in ['top', 'bottom']:
                extreme_val = max(v[1] for v in vertices) if side == 'top' else min(v[1] for v in vertices)
                extreme_vertices = [v for v in vertices if abs(v[1] - extreme_val) < 1e-6]
            else: # 'left', 'right'
                extreme_val = min(v[0] for v in vertices) if side == 'left' else max(v[0] for v in vertices)
                extreme_vertices = [v for v in vertices if abs(v[0] - extreme_val) < 1e-6]

            # Create an outward-pointing pin from each extreme vertex
            for v_extreme in extreme_vertices:
                vec_outward = np.array(v_extreme) - np.array(center_coords)
                norm = np.linalg.norm(vec_outward)
                if norm > 1e-9:
                    unit_vec = vec_outward / norm
                    p_end = np.array(v_extreme) + unit_vec * pin_edge_length
                    p_mid = (np.array(v_extreme) + p_end) / 2.0
                    new_pins.append([v_extreme[0], v_extreme[1], p_end[0], p_end[1], p_mid[0], p_mid[1], skfp_index])
                    pinned_count += 1
    
    pin_type = "Fixed" if skfp_index == 1.0 else "Free"
    print(f"[Append Pins] Found {len(boundary_hexagons)} boundary hexagons on '{side}' side.")
    print(f"              Added {pinned_count} {pin_type} pins (SkFp={skfp_index}).")
    
    df_new = pd.DataFrame(new_pins, columns=["X1", "Y1", "X2", "Y2", "XC", "YC", "SkFpIndex"])
    out_data = pd.concat([data, df_new], ignore_index=True)
    out_data.to_csv(output_csv, index=False, float_format='%.4f')
    print(f"[Append Pins] Saved '{output_csv}' with total rows={len(out_data)}")
    return output_csv

# Wrapper functions for each side
def append_pins(side, skfp_index, **kwargs):
    return _append_pins_aligned(side=side, skfp_index=skfp_index, **kwargs)

################################################################################
# Section 5: Monte Carlo Simulation
################################################################################
def run_simulation_with_pins(edges, centers, skfp, paramdict):
    """
    Runs a Monte Carlo simulation on the given lattice.
    Pins with SkFpIndex==1.0 are fixed to a predetermined inward-pointing direction.
    All other spins (SkFpIndex==0.0 or 2.0) are free to evolve.
    """
    print("\n[Simulation] Starting Monte Carlo Simulation...")
    tf.compat.v1.reset_default_graph()

    N = len(edges)
    if N == 0:
        print("[Simulation] Error: No edges/spins found.")
        return None

    # --- Prepare structural information ---
    rotmat = get_rotmat(edges)
    nnidx = None # Using distance-based cutoff instead of nearest-neighbor indices
    print(f"[Simulation] Structure info processed for {N} spins.")

    # --- Identify fixed pins and calculate their target states ---
    fixed_mask = (skfp == 1.0) # Only SkFpIndex == 1.0 are fixed
    num_fixed = np.sum(fixed_mask)
    fixed_indices = np.where(fixed_mask)[0]
    print(f"[Simulation] Total spins: {N}, Fixed spins (SkFp=1.0): {num_fixed}, Free spins: {N - num_fixed}")

    # Target states are only calculated for fixed pins; others remain [0,0,0]
    target_states_np = np.zeros((N, 3), dtype=np.float32)
    if num_fixed > 0:
        print("[Simulation] Calculating target states for fixed pins...")
        for idx in fixed_indices:
            x1, y1, x2, y2 = edges[idx]
            # Vector points from the outer point (x2, y2) to the inner lattice point (x1, y1)
            inward_vec = np.array([x1 - x2, y1 - y2])
            norm = np.linalg.norm(inward_vec)
            if norm < 1e-9:
                print(f"Warning: Fixed pin {idx} has a zero-length vector. Defaulting to [1,0,0].")
                target_states_np[idx, :] = [1.0, 0.0, 0.0]
            else:
                sx, sy = inward_vec / norm
                target_states_np[idx, :] = [sx, sy, 0.0]

    # --- Generate initial random spin states ---
    batch_size = paramdict.get("BatchSize", 1)
    X_init_np = get_IC(N, rotmat=rotmat, batch_size=batch_size) # Shape: (BatchSize, N, 3)
    
    # --- Apply the fixed target states to the initial configuration ---
    if num_fixed > 0:
        target_states_batch = np.tile(target_states_np[np.newaxis, :, :], (batch_size, 1, 1))
        fixed_mask_batch = np.broadcast_to(fixed_mask[np.newaxis, :, np.newaxis], (batch_size, N, 3))
        X_init_np = np.where(fixed_mask_batch, target_states_batch, X_init_np)
        print("[Simulation] Applied fixed target states to the initial spin configurations.")

    # --- Build TensorFlow Graph for Simulation ---
    try:
        X_ph = tf.compat.v1.placeholder(tf.float32, shape=X_init_np.shape)
        tfX = tf.compat.v1.Variable(X_ph, dtype=tf.float32)
        
        dipBasis = tf.constant(get_dipbasis(centers, paramdict.get("DR", 1.0), nnidx))
        totalHeff = get_dipheff(tfX, paramdict.get("Dip", 1.0), dipBasis)
        dipEnergy = tf.reduce_mean(-tf.reduce_sum(tfX * totalHeff / 2.0, axis=-1))

        T = tf.compat.v1.placeholder(tf.float64, shape=[])
        nexttfX_candidate = get_MultiFlip_MPMC_engine(tfX, T, totalHeff)

        # --- Pinning Logic in the Graph ---
        if num_fixed > 0:
            fixed_mask_tf = tf.constant(fixed_mask, dtype=tf.bool)
            fixed_mask_tiled_3d = tf.tile(fixed_mask_tf[None, :, None], [tf.shape(tfX)[0], 1, 3])
            target_states_tf = tf.tile(tf.constant(target_states_np[None, :, :]), [tf.shape(tfX)[0], 1, 1])
            # Where mask is True (fixed pin), use target state; otherwise, use the updated candidate state.
            next_with_pins = tf.compat.v1.where(fixed_mask_tiled_3d, target_states_tf, nexttfX_candidate)
        else:
            next_with_pins = nexttfX_candidate # No pins to fix

        update_op = tfX.assign(next_with_pins)
        init_op = tf.compat.v1.global_variables_initializer()

    except Exception as e:
        print(f"[Simulation] Error during TensorFlow graph construction: {e}")
        return None

    # --- Run TensorFlow Session ---
    config = tf.compat.v1.ConfigProto()
    config.gpu_options.allow_growth = True
    X_final = None
    
    with tf.compat.v1.Session(config=config) as sess:
        sess.run(init_op, feed_dict={X_ph: X_init_np})
        
        total_iter = paramdict.get("Total_Iteration", 10000)
        sub_iter = paramdict.get("Sub_Iteration", 1000)
        print(f"[Simulation] Starting simulation loop for {total_iter} iterations...")
        
        clock = MyClock(); clock.init()
        for it in range(total_iter):
            T_value = get_Tfeed(it, paramdict)
            sess.run(update_op, feed_dict={T: T_value})
            
            if it % sub_iter == 0 or it == total_iter - 1:
                energy_val = sess.run(dipEnergy)
                elapsed = clock.tictoc()
                print(f"Iter {it}/{total_iter} | T={T_value:.4f} | Avg E={energy_val:.6f} | Step Time: {elapsed:.3f}s")
        
        X_final = sess.run(tfX)
        if not np.all(np.isfinite(X_final)):
            print("!!! Warning: Final spin state contains NaN/Inf values !!!")
            return None
        print(f"[Simulation] Simulation finished. Final dataset shape: {X_final.shape}")
        
    return X_final

################################################################################
# Section 6: Result Saving and Visualization
################################################################################
def save_simulation_results(base_dir, cols, rows, removed_hex_info,
                            edges, centers, skfp, sim_data, pin_info, dr_value):
    """Saves all simulation artifacts to a uniquely named directory."""
    if sim_data is None:
        print("[Result Save] Error: Simulation data is None. Skipping save.")
        return

    print("[Result Save] Saving simulation results...")
    
    removed_str = "None"
    if removed_hex_info:
        removed_str = "_".join([f"c{c}r{r}" for c, r in removed_hex_info])

    dataset_dir_name = f"Sim_C{cols}R{rows}_Rm-{removed_str}_Pins-{pin_info}_DR{dr_value:.2f}"
    dataset_dir_path = os.path.join(base_dir, dataset_dir_name)
    os.makedirs(dataset_dir_path, exist_ok=True)
    
    try:
        nodes = np.unique(np.concatenate([edges[:, :2], edges[:, 2:]], axis=0), axis=0)
        rotmat = get_rotmat(edges)
        nnidx = get_nnidx(edges) # This can be slow for large systems
        
        np.save(os.path.join(dataset_dir_path, "Edges.npy"), edges)
        np.save(os.path.join(dataset_dir_path, "CenterOfEdges.npy"), centers)
        np.save(os.path.join(dataset_dir_path, "Nodes.npy"), nodes)
        np.save(os.path.join(dataset_dir_path, "Rotmat.npy"), rotmat)
        np.save(os.path.join(dataset_dir_path, "NNIndices.npy"), nnidx)
        np.save(os.path.join(dataset_dir_path, "SkFpIndex.npy"), skfp)
        np.save(os.path.join(dataset_dir_path, "TrainData.npy"), sim_data)

        num_samples, num_spins = sim_data.shape[0], sim_data.shape[1]
        with open(os.path.join(dataset_dir_path, "info.txt"), "w") as f:
            f.write(f"BatchSize = {num_samples}\n")
            f.write(f"NumberOfSpins = {num_spins}\n")
            f.write(f"RemovedHexagons = {removed_hex_info}\n")
            f.write(f"PinningInfo = {pin_info}\n")
        print(f"[Result Save] All results saved to: {dataset_dir_path}")
    except Exception as e:
        print(f"[Result Save] Error during file saving: {e}")

def plot_final_lattice(csv_file, title="Lattice Structure"):
    """Visualizes the final lattice structure from a CSV file."""
    try:
        data = pd.read_csv(csv_file)
    except Exception as e:
        print(f"[Plotting] Error reading CSV '{csv_file}': {e}")
        return
        
    plt.figure(figsize=(12, 12))
    
    pin_colors = {0.0: 'gray', 1.0: 'red', 2.0: 'blue'}
    pin_labels = {0.0: 'Original Lattice', 1.0: 'Fixed Pins', 2.0: 'Free Pins'}
    
    for skfp_val, color in pin_colors.items():
        mask = (data["SkFpIndex"] == skfp_val)
        if np.any(mask):
            edges = data.loc[mask, ["X1", "Y1", "X2", "Y2"]].values
            centers = data.loc[mask, ["XC", "YC"]].values
            label = f"{pin_labels[skfp_val]} (N={len(edges)})"
            for e in edges:
                plt.plot([e[0], e[2]], [e[1], e[3]], color=color, lw=1.0, alpha=0.7)
            # Scatter plot with a single label for the group
            plt.scatter([], [], color=color, label=label) 
            
    plt.title(title, fontsize=16)
    plt.xlabel("X coordinate")
    plt.ylabel("Y coordinate")
    plt.legend()
    plt.grid(True, linestyle=':', alpha=0.5)
    plt.axis('equal')
    plt.tight_layout()
    plt.show()

################################################################################
# Section 7: Main Execution Logic
################################################################################
def main():
    """Main execution function to generate a lattice and run simulation."""
    print("="*70)
    print("Hexagonal Lattice Dataset Generation with Boundary Pinning")
    print("="*70)

    # --- Configuration ---
    base_dir = os.path.join(os.getcwd(), "datasets")
    os.makedirs(base_dir, exist_ok=True)
    
    lattice_a = 1.0 / np.sqrt(3) # Side length of a hexagon
    grid_cols = 16
    grid_rows = 13
    
    # List of (col, row) tuples for hexagons to remove
    hex_to_remove = [] # Example: [(0,0), (grid_cols-1, grid_rows-1)]

    pin_interval = 1 # Add a pin at every Nth boundary hexagon
    pin_edge_len = lattice_a
    pin_threshold = 1e-3 # Tolerance to find boundary hexagons
    
    # Simulation parameters
    paramdict = {
        "Total_Iteration": 100000, "Sub_Iteration": 10000, "Tstart": 3.0, "Tend": 0.01,
        "Annealing%": 0.95, "Dip": 1.0, "DR": 1000.00, "BatchSize": 30000
    }
    
    # --- File Naming ---
    removed_tag = "NR" if not hex_to_remove else "Custom"
    base_filename = f"Lattice_C{grid_cols}R{grid_rows}_Rm-{removed_tag}"
    
    # --- Pipeline Execution ---
    global hex_centers_post_removal

    # Step A: Generate initial grid
    print("\n--- Step A: Generating Hexagon Grid ---")
    initial_hex_centers = generate_hexagon_grid(grid_cols, grid_rows, lattice_a)

    # Step B: Remove specified hexagons
    print("\n--- Step B: Removing Specified Hexagons ---")
    hex_centers_post_removal = list(initial_hex_centers)
    if hex_to_remove:
        for col_r, row_r in hex_to_remove:
            hex_centers_post_removal = remove_hex_by_colrow(hex_centers_post_removal, col_r, row_r)
    else:
        print("No hexagons specified for removal.")

    # Step C: Create CSV from the base lattice
    print("\n--- Step C: Saving Base Lattice to CSV ---")
    base_lattice_csv = os.path.join(base_dir, f"{base_filename}_base.csv")
    save_unique_lattice_to_csv(hex_centers_post_removal, lattice_a, base_lattice_csv)

    # Step D: Sequentially add pins to all sides
    print("\n--- Step D: Appending Pins to Boundaries ---")
    pin_config = [
        {'side': 'top',    'skfp_index': 2.0}, # Free Pin
        {'side': 'bottom', 'skfp_index': 2.0}, # Free Pin
        {'side': 'left',   'skfp_index': 2.0}, # Free Pin
        {'side': 'right',  'skfp_index': 2.0}  # Free Pin
    ]
    
    current_csv = base_lattice_csv
    for i, config in enumerate(pin_config):
        output_csv = os.path.join(base_dir, f"{base_filename}_pins_{i+1}.csv")
        current_csv = append_pins(
            input_csv=current_csv, output_csv=output_csv, a=lattice_a,
            pin_threshold=pin_threshold, pin_edge_length=pin_edge_len,
            pin_interval=pin_interval, **config
        )
        if current_csv is None:
            print(f"Error: Failed to add pins for side '{config['side']}'. Aborting.")
            return

    final_lattice_csv = current_csv
    pin_info_str = "AllSidesFree" # Describe the final pinning state

    # Step E: Visualize the final lattice structure
    print("\n--- Step E: Plotting Final Lattice with All Pins ---")
    plot_title = f"Lattice {grid_cols}x{grid_rows} ({removed_tag} Removal) - {pin_info_str}"
    plot_final_lattice(final_lattice_csv, title=plot_title)

    # Step F: Run the simulation on the final lattice
    print("\n--- Step F: Running Monte Carlo Simulation ---")
    edges_arr, centers_arr, skfp_arr = load_structure_from_csv(final_lattice_csv)
    if edges_arr is None:
        print("Error: Failed to load final lattice for simulation. Aborting.")
        return
        
    sim_data = run_simulation_with_pins(edges_arr, centers_arr, skfp_arr, paramdict)
    if sim_data is None:
        print("Error: Simulation failed. Aborting.")
        return

    # Step G: Save all results
    print("\n--- Step G: Saving Final Results ---")
    save_simulation_results(
        base_dir, grid_cols, grid_rows, hex_to_remove,
        edges_arr, centers_arr, skfp_arr,
        sim_data, pin_info_str, paramdict["DR"]
    )

    print("\n" + "="*70)
    print("Dataset Generation Pipeline Finished Successfully!")
    print("="*70)

################################################################################
# Section 8: Execution Trigger
################################################################################
if __name__ == "__main__":
    main()
